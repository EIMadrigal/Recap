 1. 算法题：LC 113变种，只要输出一条路径
    ```cpp
    vector<int> pathSum(TreeNode* root, int sum) {
      vector<int> ans;
      path(root, sum, ans);
      return ans;
    }

    bool path(TreeNode* root, int sum, vector<int>& ans) {
      if (!root) return false;
      ans.push_back(root->val);
      if (!root->left && !root->right && root->val == sum) {
        return true;
      }
      if (path(root->left, sum - root->val, ans) || path(root->right, sum - root->val, ans))
        return true;
      else {
        ans.pop_back();
        return false;
      }
    }
    ```
    之所以将返回值设为`bool`而非按照113题的写法：
    ```cpp
    void pathSum(TreeNode* root, int sum, vector<int>& ans) {
        if(!root) {
            return;
        }
        
        ans.push_back(root->val);
        if(!root->left && !root->right && root->val == sum) {
            return;
        }
        pathSum(root->left, sum - root->val, ans);
        pathSum(root->right, sum - root->val, ans);
        ans.pop_back();
    }
    ```
    主要是因为`ans.pop_back()`，113写法中不论是否找到满足要求的路径都会`pop`，这显然不符合我们的想法。
    例如对于[1,2,3] sum=4, 到2时ans=[1,2], 2左右均空返回到46行，弹出2ans=[1], 回到45行开始访问1的右子树，ans=[1,3], 42行找到了一条满足条件的路径，返回到46行，ans弹出3，回到root结束ans=[1]。因此错误就在于尽管找到了路径，但是返回上一层时会把该正确路径的最后一个元素弹走。
    正确写法中25行如果左子树或右子树找到了一条路径（需要bool），就直接返回上一层不弹出，只有左右都不满足条件ans才弹出当前层节点。

    数据结构：跳表
 2. 计网
    什么情况下会发送RST包
    TCP连接中一方宕机了会发生什么
    SYN攻击？如何避免？
    HTTP状态码
    HTTPS如何保证安全性
 3. 数据库
    事务？ACID？如何保证？
 4. OS
    进程和线程？
    协程？和线程区别？
    什么是文件系统？虚拟文件系统？EXT4
 5. 分布式
    了解分布式吗？Spark？

