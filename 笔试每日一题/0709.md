小红书  
[0,4,7]: 0表示无色，变红代价4，变蓝代价7  
[1,x,x]: 1表示石头已经是红色  
[2,x,x]: 2表示石头已经是蓝色  
给一批小石头，要求最后所有石头都有色，且红色和蓝色一样多，返回最小染色代价  
如果无法做到，返回-1

```cpp
int minCost(vector<vector<int>>& stones) {
    const int n = stones.size();
    if (n & 1) {
        return -1;
    }
    int zero = 0, red = 0, blue = 0;
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if (stones[i][0] == 0) {
            ++zero;
            res += stones[i][1];  // 先全部变红, 再选择一些改换颜色
        } else if (stones[i][0] == 1) {
            ++red;
        } else if (stones[i][0] == 2) {
            ++blue;
        }
    }
    if (red > (n >> 1) || blue > (n >> 1)) {
        return -1;
    }
    sort(stones.begin(), stones.end(), [](const vector<int>& a, const vector<int>& b) {
        return !a[0] && !b[0] ? a[1] - a[2] > b[1] - b[2] : a[0] < b[0];
    });
    for (int i = 0; i < (n >> 1) - blue; ++i) {
        res += stones[i][2] - stones[i][1];
    }
    return res;
}

vector<vector<int>> numbers{{1,5,3},{2,7,9},{0,6,4},{0,7,9},{0,2,1},{0,5,9}};
cout << minCost(numbers);  // 17
```
