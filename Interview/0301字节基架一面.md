## 算法题
数据结构：跳表

LC 113变种，只要输出一条路径
```cpp
vector<int> pathSum(TreeNode* root, int sum) {
    vector<int> ans;
    path(root, sum, ans);
    return ans;
}

bool path(TreeNode* root, int sum, vector<int>& ans) {
    if (!root) return false;
    ans.push_back(root->val);
    if (!root->left && !root->right && root->val == sum) {
        return true;
    }
    if (path(root->left, sum - root->val, ans) || path(root->right, sum - root->val, ans))
        return true;
    else {
        ans.pop_back();
        return false;
    }
}
```

之所以将返回值设为`bool`而非按照113题的写法：

```cpp
void pathSum(TreeNode* root, int sum, vector<int>& ans) {
    if(!root) {
        return;
    }
        
    ans.push_back(root->val);
    if(!root->left && !root->right && root->val == sum) {
        return;
    }
    pathSum(root->left, sum - root->val, ans);
    pathSum(root->right, sum - root->val, ans);
    ans.pop_back();
}
```

主要是因为`ans.pop_back()`，113写法中不论是否找到满足要求的路径都会`pop`，这显然不符合我们的想法。  
例如对于[1,2,3] sum=4, 到2时ans=[1,2], 2左右均空返回到46行，弹出2ans=[1], 回到45行开始访问1的右子树，ans=[1,3], 42行找到了一条满足条件的路径，返回到46行，ans弹出3，回到root结束ans=[1]。因此错误就在于尽管找到了路径，但是返回上一层时会把该正确路径的最后一个元素弹走。  
正确写法中25行如果左子树或右子树找到了一条路径（需要bool），就直接返回上一层不弹出，只有左右都不满足条件ans才弹出当前层节点。

## 计网
 1. 什么情况下会发送RST包
 2. TCP连接中一方宕机了会发生什么
 3. SYN攻击？如何避免？
 4. HTTP状态码
 5. HTTPS如何保证安全性

## 数据库
 1. 事务？
 2. ACID？如何保证？

## OS
 1. 进程和线程？
 2. 协程？和线程区别？
 3. 什么是文件系统？虚拟文件系统？EXT4

## 分布式
 1. 了解分布式吗？
 2. Spark？
