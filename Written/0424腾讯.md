2h5题, 不知道怎么评价, 感觉出的题挺有新意的吧

## 1 水题
给n个数字字符串, 长度均为m, 要求从上向下构造数字, 排序输出 100%
```
4
0000
0101
1011
0111
输出 10 11 101 111
```
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	vector<string> s(n);
	for (int i = 0; i < n; ++i) {
		cin >> s[i];
	}
	
	int m = s[0].size();
	vector<int> ans(m, 0);
	for (int i = 0; i < m; ++i) {
		for (int j = 0; j < n; ++j) {
			ans[i] = ans[i] * 10 + (s[j][i] - '0');
		}
	}
	sort(ans.begin(), ans.end());
	for (int a : ans) {
		cout << a << " ";
	}
	return 0;
}
```

## 2 素数打表
给一个数组下标1-n, 每次淘汰下标非素数的元素, 重新构成数组, 求最后剩下的元素  100%  
输入 3 1 1 4 5 6 输出 5  
我写的复杂了, 用`vis`表示是否访问过, `index`表示新的下标. 其实只要不断覆盖原数组即可.
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param a int整型vector 
     * @return int整型
     */
    int getNumber(vector<int>& a) {
        int n = a.size();
        vector<int> primes = getPrime(n + 1);
        while (n > 1) {
        	int k = 0;
        	for (int i = 0; i < n; ++i) {
        		if (primes[i] > n)
        			break;
        		a[k++] = a[primes[i] - 1];
        	}
        	n = k;
        }
        return a[0];
    }

    vector<int> getPrime(int n) {
    	vector<int> primes;
    	vector<bool> isprime(n, true);
    	isprime[0] = false, isprime[1] = false;
    	for (int i = 2; i * i <= n; ++i) {
    		if (isprime[i]) {
    			for (int j = i * i; j <= n; j += i) {
    				isprime[j] = false;
    			}
    		}
    	}
    	for (int i = 0; i < n; ++i) {
    		if (isprime[i])
    			primes.push_back(i);
    	}
    	return primes;
    }
};

int main() {
	int n;
	cin >> n;
	vector<int> a(n);
	for (int i = 0; i < n; ++i) {
		cin >> a[i];
	}
	Solution s;
	cout << s.getNumber(a) << "\n";
	return 0;
}
```

## 3 
