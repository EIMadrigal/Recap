## 0709 小红书
[0,4,7]: 0表示无色，变红代价4，变蓝代价7  
[1,x,x]: 1表示石头已经是红色  
[2,x,x]: 2表示石头已经是蓝色  
给一批小石头，要求最后所有石头都有色，且红色和蓝色一样多，返回最小染色代价  
如果无法做到，返回-1

```cpp
int minCost(vector<vector<int>>& stones) {
    const int n = stones.size();
    if (n & 1) {
        return -1;
    }
    int zero = 0, red = 0, blue = 0;
    int res = 0;
    for (int i = 0; i < n; ++i) {
        if (stones[i][0] == 0) {
            ++zero;
            res += stones[i][1];  // 先全部变红, 再选择一些改换颜色
        } else if (stones[i][0] == 1) {
            ++red;
        } else if (stones[i][0] == 2) {
            ++blue;
        }
    }
    if (red > (n >> 1) || blue > (n >> 1)) {
        return -1;
    }
    sort(stones.begin(), stones.end(), [](const vector<int>& a, const vector<int>& b) {
        return !a[0] && !b[0] ? a[1] - a[2] > b[1] - b[2] : a[0] < b[0];
    });
    for (int i = 0; i < (n >> 1) - blue; ++i) {
        res += stones[i][2] - stones[i][1];
    }
    return res;
}

vector<vector<int>> numbers{{1,5,3},{2,7,9},{0,6,4},{0,7,9},{0,2,1},{0,5,9}};
cout << minCost(numbers);  // 17
```

## 0710
n个动物重量是nums，从左向右选择，选中的左边动物的总重量不能超过自己的重量，问最多能选多少个动物(不能打乱原始数组)  
例子：[1,3,5,7,9,11,21]，最多可选[1,3,5,9,21]

最长递增子序列变体
```cpp
int animals(vector<int>& nums) {
    if (nums.empty()) {
        return 0;
    }
    const int n = nums.size();
    vector<int> dp{nums[0]};
    for (int i = 1; i < n; ++i) {
        if (nums[i] < dp.back()) {
            auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
            *it = min(nums[i] + *(it - 1), dp.back());
        } else if (nums[i] >= dp.back()) {
            dp.push_back(dp.back() + nums[i]);
        }
    }
    return dp.size();
}
```

## 0711 [理财产品](https://leetcode.cn/contest/cnunionpay-2022spring/problems/I4mOGz/)
```cpp
class Solution {
public:
    int maxInvestment(vector<int>& product, int limit) {
        sort(product.rbegin(), product.rend());
        const int n = product.size();
        long long res = 0, mod = 1000000007;
        long long l = 0, r = l;
        while (limit > 0 && r < n) {
            while (r < n && product[r] == product[l]) {
                ++r;
            }
            long long big = product[l];
            long long small = r >= n ? 0 : product[r];
            long long cnt = (big - small) * r;
            if (cnt <= limit) {
                res += get(big, small + 1, r) % mod;
                res %= mod;
                limit -= cnt;
            } else {
                int a = limit / r, b = limit % r;
                res += get(big, big - a + 1, r) % mod + (big - a) * b % mod;
                res %= mod;
                limit = 0;
            }
            l = r;
        }
        return res;
    }

    long long get(long long big, long long small, long long cnt) {
        long long res = (big - small + 1) * (big + small) / 2;
        return res * cnt;
    }
};
```

