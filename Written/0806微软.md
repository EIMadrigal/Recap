[题目链接](https://www.nowcoder.com/discuss/1006450) 最大的感受：我是傻逼

1. 整体思路是对的，从大的往小的贪心，代码写的复杂了。直接存长度到数组就行了
```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(string &S, int B) {
    map<int, int> m;  // 坑的长度 -> 该长度个数
    for (int i = 0; i < S.length(); ++i) {
        if (S[i] == '.') {
            continue;
        }
        int j = i;
        while (j < S.length() && S[j] == 'x') {
            ++j;
        }
        m[j - i]++;
        i = j;
    }
    int res = 0;
    for (auto it = m.rbegin(); it != m.rend(); it++) {
        if (B <= 0) {
            break;
        }
        int a = B / (it->first + 1);
        int b = B % (it->first + 1);
        if (it->second >= a) {
            res += a * it->first;
            B -= (it->first + 1) * a;
            res += b - 1;
            B -= b;
        } else {
            res += it->second * it->first;
            B -= (it->first + 1) * it->second;
        }
    }
    return res;
}

int solution(string &S, int B) {
    vector<int> lens;
    for (int i = 0; i < S.length(); ++i) {
        if (S[i] == '.') {
            continue;
        }
        int j = i;
        while (j < S.length() && S[j] == 'x') {
            j++;
        }
        lens.push_back(j - i);
        i = j;
    }
    sort(lens.rbegin(), lens.rend());
    int res = 0;
    for (int i = 0; i < lens.size() && B > 0; ++i) {
        if (B >= lens[i] + 1) {
            res += lens[i];
            B -= lens[i] + 1;
        } else {
            res += B - 1;
            B = 0;
        }
    }
    return res;
}

int main(int argc, char* argv[]) {
    vector<string> vec{"...xxx..x....xxx.", "..xxxxx", "x.x.xxx...x", ".."};
    vector<int> B{7, 4, 14, 5};
    for (int i = 0; i < B.size(); ++i) {
        cout << solution(vec[i], B[i]) << "\n";  // 5 3 6 0
    }
    return 0;
}
```
2. 没思路不会做。开始想把所有的R往最长的R串合并，样例2就不对。后来想按长度从大到小合并，样例2也不对。最后想试试并查集，merge时候谁是根未知，距离不知道咋算。LC1703变种  
寻找所有R位置的中位数，直接所有R往中位数靠拢，打死我也想不到。。。
```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(string &S) {
    vector<int> rpos;
    for (int i = 0; i < S.length(); ++i) {
        if (S[i] == 'R') {
            rpos.push_back(i);
        }
    }
    int middle = rpos.size() / 2;
    long long res = 0;
    for (int i = 0; i < rpos.size(); ++i) {
        if (i != middle) {
            res += abs(rpos[i] - rpos[middle]) - 1;
        }
    }
    const int mod = 1e9;
    if (res > mod) {
        return -1;
    }
    return res;
}

int main(int argc, char* argv[]) {
    vector<string> vec{"WRRWWR", "WWRWWWRWR", "WWW"};
    string s = "";
    for (int i = 0; i < 100000; ++i) {
        s += "RW";
    }
    vec.push_back(s);
    for (int i = 0; i < vec.size(); ++i) {
        cout << solution(vec[i]) << "\n";  // 2 4 0 -1
    }
    return 0;
}
```
3. 二分图匹配，匈牙利算法，没学过。。。
```cpp

```
