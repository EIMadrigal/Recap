[题目讨论](https://www.nowcoder.com/discuss/1013868)
## 模拟 100
语文阅读不好，这题就不好做了
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char* argv[]) {
    int n, t;
    cin >> n >> t;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    int cur = 0, cnt = 0;
    for (int i = 0; i < n; ++i) {
        if (cur + t <= a[i]) {
            ++cnt;
            cur += t;
        }
    }
    cout << n - cnt << "\n";
    return 0;
}
```

## 模拟 100
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char* argv[]) {
    int n, m, k;
    string s;
    cin >> n >> m >> k;
    cin >> s;
    vector<vector<bool>> vis(n, vector<bool>(m, false));
    int p = 0, q = 0, cnt = 1;
    int i = 0;
    vis[0][0] = true;
    for (i = 0; i < k; ++i) {
        if (s[i] == 'W') {
            --p;
        } else if (s[i] == 'A') {
            --q;
        } else if (s[i] == 'S') {
            ++p;
        } else if (s[i] == 'D') {
            ++q;
        }
        if (!vis[p][q]) {
            vis[p][q] = true;
            ++cnt;
        }
        if (cnt == n * m) {
            break;
        }
    }
    if (cnt == n * m) {
        cout << "Yes\n" << i << "\n";
    } else {
        cout << "No\n" << n * m - cnt << "\n";
    }
    return 0;
}
```

## 扑克牌 36
这题做的时候感觉和约瑟夫环那题很像，一直在推公式，最后随便用`prev_permutation`骗了点分。本质上还是个傻逼模拟题  
两个人从数组开头抽两张牌放到数组末尾，然后开头的牌固定，在剩下的牌中继续操作。给定最后的牌，求初始的牌。  
正向：第一轮n张牌参加，第二轮后n-1张牌，...，最后1张牌  
反向：第一轮最后一张牌参加，第二轮后2张牌，...，最后一轮所有牌。从末尾拿牌放到开头。**双端队列**
```cpp
// [1,2,3,4] -> [4,2,1,3]
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char* argv[]) {
    int n;
    cin >> n;
    vector<int> a(n), res(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    deque<int> dq;
    for (int i = n - 1; i >= 0; --i) {
        dq.push_front(a[i]);
        dq.push_front(dq.back());
        dq.pop_back();
        dq.push_front(dq.back());
        dq.pop_back();
    }
    for (auto num : dq) {
        cout << num << " ";
    }
    return 0;
}
```

## 三数之和变种 81
开始用哈希做了，总是不对，就暴力骗了点分。找(i,j,k)个数使得a[i] + a[k] == 3 * a[j]，i < j < k  
三数之和是找元素，不能有重复的元组，这题是找下标，意味着具体的元组可以重复
```cpp
// [4,2,2,2] -> 3

```

## 
