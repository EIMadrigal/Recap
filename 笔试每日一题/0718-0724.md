## 0718 木头切割问题
给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。  
输入两行，第一行n, k，第二行为数组序列。输出最大值。
```
输入
5 5
4 7 2 10 5
输出
4
解释：如图，最多可以把它分成5段长度为4的木头
数据保证有解，即结果至少是1
```
```cpp
#include <bits/stdc++.h>
using namespace std;

bool check(vector<int>& nums, int k, int len) {
    int cnt = 0;
    for (int i = 0; i < nums.size(); ++i) {
        cnt += nums[i] / len;
    }
    return cnt >= k;
}

int bruteForce(vector<int>& nums, int k) {
    int maxLen = *max_element(nums.begin(), nums.end());
    int m = 1;
    for (m = 1; m <= maxLen; ++m) {
        if (!check(nums, k, m)) {
            break;
        }
    }
    return m - 1;
}

int main(int argc, char* argv[]) {
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    int l = 1, r = 1;
    for (int i = 0; i < n; ++i) {
        cin >> nums[i];
        r = max(r, nums[i]);
    }
    ++r;
    while (l < r) {
        int m = l + (r - l) / 2;
        if (check(nums, k, m)) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    cout << l - 1 << "\n";
    cout << bruteForce(nums, k) << "\n";
    return 0;
}
```

## 0719

## 0720

## 0721

## 0722

## 0723

## 0724
