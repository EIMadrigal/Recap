[题目链接](https://www.nowcoder.com/discuss/1006450) 最大的感受：我是傻逼

1. 整体思路是对的，从大的往小的贪心，代码写的复杂了。直接存长度到数组就行了
```cpp
#include <bits/stdc++.h>
using namespace std;

int solution(string &S, int B) {
    map<int, int> m;  // 坑的长度 -> 该长度个数
    for (int i = 0; i < S.length(); ++i) {
        if (S[i] == '.') {
            continue;
        }
        int j = i;
        while (j < S.length() && S[j] == 'x') {
            ++j;
        }
        m[j - i]++;
        i = j;
    }
    int res = 0;
    for (auto it = m.rbegin(); it != m.rend(); it++) {
        if (B <= 0) {
            break;
        }
        int a = B / (it->first + 1);
        int b = B % (it->first + 1);
        if (it->second >= a) {
            res += a * it->first;
            B -= (it->first + 1) * a;
            res += b - 1;
            B -= b;
        } else {
            res += it->second * it->first;
            B -= (it->first + 1) * it->second;
        }
    }
    return res;
}

int solution(string &S, int B) {
    vector<int> lens;
    for (int i = 0; i < S.length(); ++i) {
        if (S[i] == '.') {
            continue;
        }
        int j = i;
        while (j < S.length() && S[j] == 'x') {
            j++;
        }
        lens.push_back(j - i);
        i = j;
    }
    sort(lens.rbegin(), lens.rend());
    int res = 0;
    for (int i = 0; i < lens.size() && B > 0; ++i) {
        if (B >= lens[i] + 1) {
            res += lens[i];
            B -= lens[i] + 1;
        } else {
            res += B - 1;
            B = 0;
        }
    }
    return res;
}

int main(int argc, char* argv[]) {
    vector<string> vec{"...xxx..x....xxx.", "..xxxxx", "x.x.xxx...x", ".."};
    vector<int> B{7, 4, 14, 5};
    for (int i = 0; i < B.size(); ++i) {
        cout << solution(vec[i], B[i]) << "\n";  // 5 3 6 0
    }
    return 0;
}
```
2. 
3. 
